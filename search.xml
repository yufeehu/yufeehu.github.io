<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2020/05/28/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Hello-Hexo"><a href="#Hello-Hexo" class="headerlink" title="Hello Hexo"></a>Hello Hexo</h2><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><a id="more"></a>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Markdown语法详解</title>
    <url>/2020/05/28/markdown/</url>
    <content><![CDATA[<h1 id="Markdown语法详解"><a href="#Markdown语法详解" class="headerlink" title="Markdown语法详解"></a>Markdown语法详解</h1><p>#(空格)+标题名字    —— 几个#就是几级标题</p>
<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><a id="more"></a>


<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p><strong>Hello,World! **    ——文本左右两边放</strong>就是加粗</p>
<p><em>Hello,World!</em>    ——文本左右两边放*就是斜体</p>
<p><strong><em>Hello,World!</em></strong>    ——文本左右两边放***就是斜体且加粗</p>
<p><del>Hello,World!</del>    ——文本左右两边放~~就是划去</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote>
<p>我买几个橘子去。你就在此地，不要走动。——引用： &gt;(空格)+文本</p>
</blockquote>
<h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><hr>
<p>—或者***</p>
<hr>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1590605835385&di=c3d372fbf9906a873ad96868a07b31a4&imgtype=0&src=http%3A%2F%2Fa0.att.hudong.com%2F02%2F93%2F01300543893970147279933938013_s.jpg" alt="本地头像">)——!+[描述]+(图片路径)</p>
<h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p>[描述]+(链接地址)</p>
<p><a href="https://www.baidu.com/" target="_blank" rel="noopener">百度一下，全是广告</a></p>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>有序列表：1.(空格)</p>
<ol>
<li>A</li>
<li>B</li>
<li>C</li>
</ol>
<p>无序列表：-(空格)</p>
<ul>
<li>A</li>
<li>B</li>
<li>C</li>
</ul>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><table>
<thead>
<tr>
<th align="left">姓名</th>
<th>性别</th>
<th>年龄</th>
</tr>
</thead>
<tbody><tr>
<td align="left">张三</td>
<td>男</td>
<td>18</td>
</tr>
</tbody></table>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Hello,World!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>撤销：Ctrl + Z<br>重做：Ctrl + Y<br>加粗：Ctrl + B<br>斜体：Ctrl + I<br>标题：Ctrl + Shift + H<br>无序列表：Ctrl + Shift + U<br>有序列表：Ctrl + Shift + O<br>检查列表：Ctrl + Shift + C<br>插入代码：Ctrl + Shift + K<br>插入链接：Ctrl + Shift + L<br>插入图片：Ctrl + Shift + G</p>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>标记语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue</title>
    <url>/2020/05/30/Vue/</url>
    <content><![CDATA[<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h2 id="Vue-js是什么"><a href="#Vue-js是什么" class="headerlink" title="Vue.js是什么"></a>Vue.js是什么</h2><pre><code>Vue (读音 /vjuː/，类似于 **view**) 是一套用于构建用户界面的**渐进式框架**。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。---[来自Vue官网](https://cn.vuejs.org/)</code></pre><h3 id="MVVM模式的实现者"><a href="#MVVM模式的实现者" class="headerlink" title="MVVM模式的实现者"></a>MVVM模式的实现者</h3><ul>
<li>Model：模型层，在这里表示JavaScript对象</li>
<li>View：视图层，在这里表示DOM（HTML操作的元素）</li>
<li>ViewModel：连接视图层和数据的中间件，Vue.js就是MVVM中的ViewModel层的实现者</li>
</ul>
<hr>
<h3 id="Vue-js的优点"><a href="#Vue-js的优点" class="headerlink" title="Vue.js的优点"></a>Vue.js的优点</h3><a id="more"></a>

<ul>
<li>轻量级，Vue.js压缩后只有20多kb,体积非常小</li>
<li>移动优先，更适合移动端</li>
<li>易上手，文档齐全，官网还有手把手教你的视频教程</li>
<li>吸收了Angular（模块化）和React（虚拟DOM）的长处，并拥有自己独特的功能，如：计算属性</li>
<li>开源，社区活跃度高</li>
</ul>
<hr>
<h2 id="第一个Vue程序"><a href="#第一个Vue程序" class="headerlink" title="第一个Vue程序"></a>第一个Vue程序</h2><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><h4 id="IDEA安装Vue插件"><a href="#IDEA安装Vue插件" class="headerlink" title="IDEA安装Vue插件"></a>IDEA安装Vue插件</h4><p>​    打开idea,依次点击file——settings——Plugins,然后在Marketplace下搜索vue.js并安装，重启ideal；</p>
<h4 id="下载vue-js"><a href="#下载vue-js" class="headerlink" title="下载vue.js"></a>下载vue.js</h4><p><a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener">下载地址</a></p>
<ul>
<li><p>开发版本</p>
</li>
<li><pre><code class="HTML"><span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span>
<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>
<span class="comment"><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;&#96;&#96;HTML</span><br><span class="line">  &lt;!-- 生产环境版本，优化了尺寸和速度 --&gt;</span><br><span class="line">  &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></span></code></pre>
</li>
<li><p>CDN</p>
<script src="https://cdn.jsdelivr.net/npm/vue@2.6.11/dist/vue.js"></script>

<script src="https://cdn.jsdelivr.net/npm/vue@2.6.11/dist/vue.min.js"></script>





</li>
</ul>
<h3 id="完成实例"><a href="#完成实例" class="headerlink" title="完成实例"></a>完成实例</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">xmlns:v-bind</span>=<span class="string">"http://www.w3.org/1999/xhtml"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--1.引入Vue.js--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue@2.6.11/dist/vue.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--view层 模板--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">	&#123;&#123;message&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">"#app"</span>,</span></span><br><span class="line"><span class="actionscript">        <span class="comment">//Model层：数据</span></span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="actionscript">            message:<span class="string">"hello vue!"</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>​    指令 (Directives) 是带有 <code>v-</code> 前缀的特殊属性，指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-bind:title</span>=<span class="string">"message"</span>&gt;</span></span><br><span class="line">       鼠标悬停几秒钟查看此处动态绑定的提示信息！</span><br><span class="line">   <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    这里，v-bind指令就是将title特性和Vue实例中的message属性进行绑定。</p>
<h2 id="绑定事件"><a href="#绑定事件" class="headerlink" title="绑定事件"></a>绑定事件</h2><p>​    可以用 <code>v-on</code> 指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码。下面是<a href="https://cn.vuejs.org/v2/guide/events.html" target="_blank" rel="noopener">Vue官网</a>的一个例子。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-1"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"counter += 1"</span>&gt;</span>Add 1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>The button above has been clicked &#123;&#123; counter &#125;&#125; times.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> example1 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example-1'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    counter: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>​    </p>
<h2 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h2><ul>
<li><p>el属性</p>
<ul>
<li>用来指示vue编译器从什么地方开始解析 vue的语法，可以说是一个占位符。</li>
</ul>
</li>
<li><p>data属性</p>
<ul>
<li>用来组织从view中抽象出来的属性，可以说将视图的数据抽象出来存放在data中。</li>
</ul>
</li>
<li><p>template属性</p>
<ul>
<li>用来设置模板，会替换页面元素，包括占位符。</li>
</ul>
</li>
<li><p>methods属性</p>
<ul>
<li>放置页面中的业务逻辑，js方法一般都放置在methods中</li>
</ul>
</li>
<li><p>render属性</p>
<ul>
<li>创建真正的Virtual Dom</li>
</ul>
</li>
<li><p>computed属性</p>
<ul>
<li>用来计算</li>
</ul>
</li>
<li><p>watch属性</p>
<ul>
<li>watch:function(new,old){}</li>
<li>监听data中数据的变化 </li>
<li>两个参数，一个返回新值，一个返回旧值</li>
</ul>
</li>
</ul>
<h2 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h2><p>​    数据双向绑定，就是当Model层的数据发生变化，视图也会随之发生变化；当视图发生变化，Model层的数据同样也会随之发生变化。在Vue中双向绑定的指令是v-model,<code>v-model</code> 指令在表单 <code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code> 及 <code>&lt;select&gt;</code> 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 <code>v-model</code> 本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。下面有一个实例。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">xmlns:v-bind</span>=<span class="string">"http://www.w3.org/1999/xhtml"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--1.引入Vue.js--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue@2.6.11/dist/vue.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--view层 模板--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    输入文本内容<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"message"</span>/&gt;</span>&#123;&#123;message&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">"#app"</span>,</span></span><br><span class="line"><span class="actionscript">        <span class="comment">//Model层：数据</span></span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="actionscript">            message: <span class="string">""</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="Vue组件"><a href="#Vue组件" class="headerlink" title="Vue组件"></a>Vue组件</h2><p>​    组件是可复用的Vue实例，就是一组可以重复使用的模板。其实就和Thymeleaf模板引擎中的th: fragment=”xxx“类似，</p>
<p>​    这里有一个 Vue 组件的示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hello</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span> <span class="attr">v-bind:hyh</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">hello</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个Vue组件component</span></span><br><span class="line">    Vue.component(<span class="string">"hello"</span>,&#123;</span><br><span class="line">        props: [<span class="string">'hyh'</span>],</span><br><span class="line">        <span class="comment">//定义一个模板</span></span><br><span class="line">        template: <span class="string">'&lt;li&gt;&#123;&#123;hyh&#125;&#125;&lt;/li&gt;'</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el: <span class="string">"#app"</span>,</span><br><span class="line">        <span class="comment">//Model层：数据</span></span><br><span class="line">        data: &#123;</span><br><span class="line">            items: [<span class="string">'Java'</span>,<span class="string">'PHP'</span>,<span class="string">'Python'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="组件的组织"><a href="#组件的组织" class="headerlink" title="组件的组织"></a>组件的组织</h3><p>​    通常一个应用会以一棵嵌套的组件树的形式来组织：</p>
<p><img src="https://cn.vuejs.org/images/components.png" alt="Component Tree"></p>
<p>​     例如，你可能会有页头、侧边栏、内容区等组件，每个组件又包含了其它的像导航链接、博文之类的组件。</p>
<p>​     为了能在模板中使用，这些组件必须先注册以便 Vue 能够识别。这里有两种组件的注册类型：<strong>全局注册</strong>和<strong>局部注册</strong>。至此，我们的组件都只是通过 <code>Vue.component</code> 全局注册的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-component-name'</span>, &#123;</span><br><span class="line">  <span class="comment">// ... options ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>​     全局注册的组件可以用在其被注册之后的任何 (通过 <code>new Vue</code>) 新创建的 Vue 根实例，也包括其组件树中的所有子组件的模板中。</p>
<h3 id="通过-Prop-向子组件传递数据"><a href="#通过-Prop-向子组件传递数据" class="headerlink" title="通过 Prop 向子组件传递数据"></a>通过 Prop 向子组件传递数据</h3><p>​     Prop 是你可以在组件上注册的一些自定义属性。在上面的示例中，组件注册了一个名为”hyh”的属性，然后将它与数据中的for循环遍历出来的item绑定，在template中响应的是,而不是。可以理解为“hyh”类似于一个形式参数，template不能直接从Model拿数据，需要通过一个中间件。</p>
<h3 id="关于Prop的一个bug"><a href="#关于Prop的一个bug" class="headerlink" title="关于Prop的一个bug"></a>关于Prop的一个bug</h3><p>​     作者练习时发现，如果使用驼峰式定义props的参数（姑且叫它为参数），template中的数据是不能被渲染到视图层的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;定义一个Vue组件component</span><br><span class="line">    Vue.component(&quot;hello&quot;,&#123;</span><br><span class="line">        props: [&#39;pHyh&#39;],</span><br><span class="line">        &#x2F;&#x2F;定义一个模板</span><br><span class="line">        template: &#39;&lt;li&gt;&#123;&#123;pHyh&#125;&#125;&lt;&#x2F;li&gt;&#39;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>



<h2 id="Axios异步通讯"><a href="#Axios异步通讯" class="headerlink" title="Axios异步通讯"></a>Axios异步通讯</h2><p>​     Axios是一个开源的可以用在游览器和NodeJs的异步通讯框架，它的主要作用就是实现AJAX异步通讯，其功能特性如下：</p>
<ul>
<li>从浏览器中创建XMLHttpRequests</li>
<li>node.js创建http请求</li>
<li>支持Promise API</li>
<li>拦截请求和响应</li>
<li>转换请求数据和响应数据</li>
<li>取消请求</li>
<li>自动换成json数据</li>
</ul>
<p><a href="http://www.axios-js.com/" target="_blank" rel="noopener">下载地址</a></p>
<ul>
<li><p>CDN</p>
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>



</li>
</ul>
<p>​    mounted是编译好的HTML挂载到页面完成后执行的事件钩子此钩子函数中一般会做一些ajax请求获取数据进行数据初始化，所有在mounted函数中通常会用到Axions。</p>
<p>ps:钩子函数具体见<a href="https://cn.vuejs.org/v2/guide/instance.html" target="_blank" rel="noopener">Vue生命周期图示</a></p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mounted()&#123;<span class="comment">//钩子函数 链式编程</span></span><br><span class="line">           axios.get(<span class="string">'../data.json'</span>).then(<span class="function"><span class="params">response</span>=&gt;</span>(<span class="keyword">this</span>.info=response.data));</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>



<h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>​    计算属性就是一个能将计算结果缓存起来的属性（将行为转化为静态的属性）</p>
<p>以下示例，区别方法和计算属性的区别：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--view层 模板--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>timestamp1:&#123;&#123;timestamp1()&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>timestamp2:&#123;&#123;timestamp2&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el: <span class="string">"#app"</span>,</span><br><span class="line">        <span class="comment">//Model层：数据</span></span><br><span class="line">        data: &#123;</span><br><span class="line">            message:<span class="string">"hello vue!"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            timestamp1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Date</span>.now();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        computed: &#123;</span><br><span class="line">            timestamp2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.message</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Date</span>.now();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><p>待更新。。。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC</title>
    <url>/2020/06/21/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="JUC并发编程"><a href="#JUC并发编程" class="headerlink" title="JUC并发编程"></a>JUC并发编程</h1><h2 id="1、什么是JUC"><a href="#1、什么是JUC" class="headerlink" title="1、什么是JUC"></a>1、什么是JUC</h2><p><img src="C:%5CUsers%5C%E8%83%A1%E5%AE%87%E8%BE%89%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200613205215472.png" alt="image-20200613205215472"></p>
<h2 id="2、进程和线程"><a href="#2、进程和线程" class="headerlink" title="2、进程和线程"></a>2、进程和线程</h2><blockquote>
<p>进程和线程概念</p>
</blockquote>
<p>进程（Process）：一个正在运行的程序就是一个进程；</p>
<p>进程作为资源分配的单位，系统在运行时会给每个进程分配不同的内存区域。</p>
<p>线程（Thread）：线程就是一个程序内部的一条执行路径，一个进程可以有多个线程；</p>
<p>线程作为调度和执行的单位，每个线程都拥有独立的运行栈和程序计数器。</p>
<p>对Java而言创建线程的三种方式：继承Thread、实现Runnable、Callable</p>
<p><strong>Java真的能够开启线程吗？</strong> 答案是开不了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * This method is not invoked for the main method thread or "system"</span></span><br><span class="line"><span class="comment">         * group threads created/set up by the VM. Any new functionality added</span></span><br><span class="line"><span class="comment">         * to this method in the future may have to also be added to the VM.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * A zero status value corresponds to state "NEW".</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Notify the group that this thread is about to be started</span></span><br><span class="line"><span class="comment">         * so that it can be added to the group's list of threads</span></span><br><span class="line"><span class="comment">         * and the group's unstarted count can be decremented. */</span></span><br><span class="line">        group.add(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            start0();</span><br><span class="line">            started = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                    group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">                <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">                  it will be passed up the call stack */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//本地方法，调用的底层的C++，Java是运行在虚拟机上的无法直接操作硬件</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>并发和并行</p>
</blockquote>
<p>并发（Concurrent）</p>
<ul>
<li>CPU 单核，多个线程，快速交替完成</li>
</ul>
<p>并行（Parallel）</p>
<ul>
<li>CPU 多核，多个线程，同时执行完成</li>
</ul>
<p>并发编程的本质：<strong>充分利用CPU的资源</strong></p>
<blockquote>
<p>线程有几个状态</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">    	</span><br><span class="line">        <span class="comment">//新建</span></span><br><span class="line">        NEW,</span><br><span class="line"></span><br><span class="line">        <span class="comment">//运行</span></span><br><span class="line">        RUNNABLE,</span><br><span class="line"></span><br><span class="line">        <span class="comment">//阻塞</span></span><br><span class="line">        BLOCKED,</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等待</span></span><br><span class="line">        WAITING,</span><br><span class="line"></span><br><span class="line">        <span class="comment">//超时等待</span></span><br><span class="line">        TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">        <span class="comment">//终止</span></span><br><span class="line">        TERMINATED;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>wait和sleep的区别</p>
</blockquote>
<ol>
<li>wait来自Object类，sleep来自Thread类</li>
<li>wait会释放锁，sleep不会释放锁</li>
<li>wait必须在同步方法或者同步代码块中，sleep可以在任何地方使用</li>
</ol>
<h2 id="3、Lock锁"><a href="#3、Lock锁" class="headerlink" title="3、Lock锁"></a>3、Lock锁</h2><blockquote>
<p>传统的synchronized锁</p>
</blockquote>
<ul>
<li><p>同步代码块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>( 锁 )&#123;</span><br><span class="line">	<span class="comment">//被同步的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//锁，任何一个类的对象，都可以充当锁。</span></span><br><span class="line"><span class="comment">//补充：在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当锁。</span></span><br><span class="line"><span class="comment">//     在继承Thread类创建多线程的方式中，使用当前类充当锁。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>同步方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//代码</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非静态的同步方法，锁一般是this，即当前对象；</span></span><br><span class="line"><span class="comment">//静态的同步方法，锁是当前类本身，Ticket.class</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>售票示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicketDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line">        <span class="comment">// Lambda表达式的本质：作为函数式接口的实例</span></span><br><span class="line">        <span class="comment">// @FunctionalInterface 函数式接口，jdk8的新特性--&gt; Lambda表达式: (参数)-&gt;&#123;代码&#125;</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; <span class="number">60</span>;i++)&#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; <span class="number">60</span>;i++)&#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; <span class="number">60</span>;i++)&#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"C"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 售票</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">50</span>;<span class="comment">//总票数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">1</span>; <span class="comment">//卖出的票数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//传统的synchronized同步方法，使线程排队操作资源类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            number --;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"卖出了"</span>+ (i++)+<span class="string">"张票，剩余"</span> + number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<blockquote>
<p>Lock接口</p>
</blockquote>
<p><img src="C:%5CUsers%5C%E8%83%A1%E5%AE%87%E8%BE%89%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200614173317277.png" alt="image-20200614173317277"></p>
<p><img src="C:%5CUsers%5C%E8%83%A1%E5%AE%87%E8%BE%89%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200614173007233.png" alt="image-20200614173007233"></p>
<p><img src="C:%5CUsers%5C%E8%83%A1%E5%AE%87%E8%BE%89%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200614174305560.png" alt="image-20200614174305560"></p>
<p>公平锁：先来后到。无论线程需要多长时间完成，都必须先来的线程执行完了，后面的线程才能执行</p>
<p>非公平锁（默认）：可以插队。时间短的线程如果排在时间长的线程后面，可以插队到前面完成</p>
<ul>
<li><p>售票示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicketDemo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Ticket2 ticket = <span class="keyword">new</span> Ticket2();</span><br><span class="line">        <span class="comment">// @FunctionalInterface 函数式接口，jdk8的新特性--&gt; lambda表达式: (参数)-&gt;&#123;代码&#125;</span></span><br><span class="line">        <span class="comment">//for循环中只有一行代码&#123;&#125;可以省略</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; <span class="number">60</span>;i++) ticket.sale(); &#125;,<span class="string">"A"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; <span class="number">60</span>;i++) ticket.sale(); &#125;,<span class="string">"B"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; <span class="number">60</span>;i++) ticket.sale(); &#125;,<span class="string">"C"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//资源类  售票</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket2</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">50</span>;<span class="comment">//总票数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">1</span>; <span class="comment">//卖出的票数</span></span><br><span class="line">    <span class="comment">//Lock锁</span></span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();<span class="comment">//加锁</span></span><br><span class="line"><span class="comment">//      lock.tryLock(); // 判断是否获取锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//业务代码</span></span><br><span class="line">            <span class="keyword">if</span>(number &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                number --;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"卖出了"</span>+ (i++)+<span class="string">"张票，剩余"</span> + number);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();<span class="comment">//解锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<blockquote>
<p>Synchronized和Lock的区别</p>
</blockquote>
<ol>
<li>Synchronized 是一个Java关键字，Lock 是一个类</li>
<li>Synchronized 可不能判断锁的状态，Lock 可以判断是否获取到锁</li>
<li>Synchronized 会自动释放锁，Lock必须手动释放锁</li>
<li>Synchronized 如果线程1（获取锁，然后阻塞),线程2会一直等待线程1执行完成；Lock就不一定会等待下去</li>
<li>Synchronized 可重入锁，不可中断的，非公平锁；Lock 可重入锁，可以判断锁（tryLock），非公平锁（可以设置为公平）</li>
<li>Synchronized  适合锁少量的同步代码，Lock 适合锁大量的代码同步代码</li>
</ol>
<blockquote>
<p>锁是什么，如何判断锁 </p>
</blockquote>
<h2 id="4、生产者和消费者问题"><a href="#4、生产者和消费者问题" class="headerlink" title="4、生产者和消费者问题"></a>4、生产者和消费者问题</h2><blockquote>
<p>生产者和消费者问题  传统的Synchronized版</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程之间的通讯问题:生产者和消费者问题！     等待唤醒，通知唤醒</span></span><br><span class="line"><span class="comment"> * 线程交替执行 A  B 操作同一个变量 num = 0</span></span><br><span class="line"><span class="comment"> * A num+1</span></span><br><span class="line"><span class="comment"> * B num-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Data data = <span class="keyword">new</span> Data();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"A"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断 等待 业务 通知</span></span><br><span class="line"><span class="comment">//资源类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number !=<span class="number">0</span>)&#123;<span class="comment">//while(number !=0)</span></span><br><span class="line">            wait();<span class="comment">//等待</span></span><br><span class="line">        &#125;</span><br><span class="line">        number++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"=&gt;"</span> + number);</span><br><span class="line">        <span class="comment">//通知其它线程我+1完了</span></span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number == <span class="number">0</span>)&#123;<span class="comment">//while(number ==0)</span></span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"=&gt;"</span> + number);</span><br><span class="line">        <span class="comment">//通知其它线程我-1完了</span></span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<p><img src="C:%5CUsers%5C%E8%83%A1%E5%AE%87%E8%BE%89%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200614225446972.png" alt="image-20200614225446972"></p>
<blockquote>
<p>虚假唤醒问题</p>
</blockquote>
<p>上面是2个线程时没问题，当有4个线程时，会出现一些意料之外的结果</p>
<p><img src="C:%5CUsers%5C%E8%83%A1%E5%AE%87%E8%BE%89%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200614230412587.png" alt="image-20200614230412587"></p>
<p><img src="C:%5CUsers%5C%E8%83%A1%E5%AE%87%E8%BE%89%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200614225938298.png" alt="image-20200614225938298"></p>
<p><strong>解决办法很简单，将上面代码Data类里方法的if判断改成while就行了</strong></p>
<blockquote>
<p>JUC版的生产者和消费者问题</p>
</blockquote>
<p><img src="C:%5CUsers%5C%E8%83%A1%E5%AE%87%E8%BE%89%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200615175121705.png" alt="image-20200615175121705"></p>
<p><img src="C:%5CUsers%5C%E8%83%A1%E5%AE%87%E8%BE%89%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200615175322659.png" alt="image-20200615175322659"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Data2 data = <span class="keyword">new</span> Data2();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"C"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"D"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断 等待 业务 通知</span></span><br><span class="line"><span class="comment">//资源类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data2</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(number !=<span class="number">0</span>)&#123;</span><br><span class="line">                condition.await();<span class="comment">//等待</span></span><br><span class="line">            &#125;</span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"=&gt;"</span> + number);</span><br><span class="line">            <span class="comment">//通知其它线程我+1完了</span></span><br><span class="line">            condition.signalAll();<span class="comment">//唤醒全部</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();<span class="comment">//解锁</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(number == <span class="number">0</span>)&#123;</span><br><span class="line">                condition.await();<span class="comment">//等待</span></span><br><span class="line">            &#125;</span><br><span class="line">            number--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"=&gt;"</span> + number);</span><br><span class="line">            <span class="comment">//通知其它线程我-1完了</span></span><br><span class="line">            condition.signalAll();<span class="comment">//唤醒全部</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();<span class="comment">//解锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>Condition 精准的通知和唤醒线程</p>
</blockquote>
<p><img src="C:%5CUsers%5C%E8%83%A1%E5%AE%87%E8%BE%89%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200615194434725.png" alt="image-20200615194434725"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程A执行完 唤醒 B， B执行完了 唤醒 C，C执行完了，唤醒 A</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Data3 data = <span class="keyword">new</span> Data3();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                data.printA();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"A"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                data.printB();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"B"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                data.printC();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"C"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断 等待 业务 通知</span></span><br><span class="line"><span class="comment">//资源类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    Condition condition1 = lock.newCondition();</span><br><span class="line">    Condition condition2 = lock.newCondition();</span><br><span class="line">    Condition condition3 = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(number != <span class="number">1</span>)&#123;</span><br><span class="line">               condition1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number = <span class="number">2</span>;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"=&gt;"</span> +<span class="string">"A在执行"</span>);</span><br><span class="line">            <span class="comment">//唤醒指定的线程 B</span></span><br><span class="line">            condition2.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(number != <span class="number">2</span>)&#123;</span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number = <span class="number">3</span>;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"=&gt;"</span> +<span class="string">"B在执行"</span>);</span><br><span class="line">            <span class="comment">//唤醒指定的线程 C</span></span><br><span class="line">            condition3.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printC</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(number != <span class="number">3</span>)&#123;</span><br><span class="line">                condition3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number = <span class="number">1</span>;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"=&gt;"</span> +<span class="string">"C在执行"</span>);</span><br><span class="line">            <span class="comment">//唤醒指定的线程 A</span></span><br><span class="line">            condition1.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="C:%5CUsers%5C%E8%83%A1%E5%AE%87%E8%BE%89%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200615204115039.png" alt="image-20200615204115039"></p>
<h2 id="5、8锁现象"><a href="#5、8锁现象" class="headerlink" title="5、8锁现象"></a>5、8锁现象</h2><h2 id="6、集合类不安全"><a href="#6、集合类不安全" class="headerlink" title="6、集合类不安全"></a>6、集合类不安全</h2><blockquote>
<p>ArrayList</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Exception: java.util.ConcurrentModificationException 并发修改异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//并发下ArrayList是线程不安全的</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 解决方案</span></span><br><span class="line"><span class="comment">         * 1、List&lt;String&gt; list = new Vector&lt;&gt;();  Vactor底层：public synchronized void addElement(E obj) 同步方法 线程安全</span></span><br><span class="line"><span class="comment">         * 2、List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());   Collections集合工具类里的synchronizedList方法</span></span><br><span class="line"><span class="comment">         * 3、List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();  写入时复制 java.util.concurrent下的接口</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="comment">//        List&lt;String&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">25</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                    list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));<span class="comment">//截取随机的唯一标识符的前5位</span></span><br><span class="line">                    System.out.println(list);</span><br><span class="line">                &#125;,String.valueOf(i)).start();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>HashSet</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SetTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//并发下 HashSet也是线程不安全的</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 解决方案</span></span><br><span class="line"><span class="comment">         * 1、Set&lt;String&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;());</span></span><br><span class="line"><span class="comment">         * 2、Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="comment">//        Set&lt;String&gt; set = new HashSet&lt;&gt;();</span></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                set.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(set);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩展：HashSet底层</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HashSet构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//HashSet的构造器干脆直接new了一个HashMap的实例</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//add 方法    本质就是map 也是存储无序、不可重复的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>HashMap</p>
</blockquote>
<p>回顾HashMap,底层默认是一个长度为16的Node[ ]数组，扩容方式是扩容为原来的2倍，并把原有的数据复制过来</p>
<p><img src="C:%5CUsers%5C%E8%83%A1%E5%AE%87%E8%BE%89%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200616130354326.png" alt="image-20200616130354326"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//并发下 HashMap 线程不安全的</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 解决方案</span></span><br><span class="line"><span class="comment">         * 1、Map&lt;String, Object&gt; map = new Hashtable&lt;&gt;();   Hashtable底层：public synchronized V put(K key, V value) 同步方法 线程安全</span></span><br><span class="line"><span class="comment">         * 2、Map&lt;String, Object&gt; map = Collections.synchronizedMap(new HashMap&lt;&gt;());</span></span><br><span class="line"><span class="comment">         * 3、Map&lt;String, Object&gt; map = new ConcurrentHashMap&lt;&gt;();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="comment">//        HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();</span></span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(map);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="7、Callable"><a href="#7、Callable" class="headerlink" title="7、Callable"></a>7、Callable</h2><p><img src="C:%5CUsers%5C%E8%83%A1%E5%AE%87%E8%BE%89%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200616134539323.png" alt="image-20200616134539323"></p>
<p>Callable 和 Runnable区别：</p>
<table>
<thead>
<tr>
<th></th>
<th>返回值</th>
<th>异常</th>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td>Callable</td>
<td>可以有返回值</td>
<td>能抛出异常</td>
<td>call</td>
</tr>
<tr>
<td>Runnable</td>
<td>没有返回值</td>
<td>不能抛出异常</td>
<td>run</td>
</tr>
</tbody></table>
<blockquote>
<p>如何让new Thread( ) 里存放Callable的实现类</p>
</blockquote>
<p><img src="C:%5CUsers%5C%E8%83%A1%E5%AE%87%E8%BE%89%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200616150618573.png" alt="image-20200616150618573"></p>
<p><img src="C:%5CUsers%5C%E8%83%A1%E5%AE%87%E8%BE%89%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200616145055723.png" alt="image-20200616145055723"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hyh.callable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//new Thread(new Runnable()).start();</span></span><br><span class="line">        <span class="comment">//FutureTask(Callable&lt;V&gt; callable)</span></span><br><span class="line">        <span class="comment">//FutureTask(Runnable runnable, V result)</span></span><br><span class="line">        FutureTask futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> MyThread());<span class="comment">//适配类</span></span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">        Integer i = (Integer)futureTask.get();<span class="comment">//获取Callable的返回值</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行call()"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1234</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="8、常用的辅助类"><a href="#8、常用的辅助类" class="headerlink" title="8、常用的辅助类"></a>8、常用的辅助类</h2><h3 id="8-1、CountDownLatch"><a href="#8-1、CountDownLatch" class="headerlink" title="8.1、CountDownLatch"></a>8.1、CountDownLatch</h3><blockquote>
<p>减法计数器</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//计数器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//总数是6，必须要执行任务的时候，再使用</span></span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"getOut"</span> );</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();<span class="comment">//等待计数器变为零，await()就会被唤醒不再阻塞，然后再向下执行</span></span><br><span class="line">        System.out.println(<span class="string">"closeDoor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="8-2、CyclicBarrier"><a href="#8-2、CyclicBarrier" class="headerlink" title="8.2、CyclicBarrier"></a>8.2、CyclicBarrier</h3><blockquote>
<p>加法计数器</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">7</span>,()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">"收集7颗龙珠成功"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"收集了"</span> + temp + <span class="string">"龙珠"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="8-3、Semaphore"><a href="#8-3、Semaphore" class="headerlink" title="8.3、Semaphore"></a>8.3、Semaphore</h3><blockquote>
<p>信号量</p>
</blockquote>
<p><img src="C:%5CUsers%5C%E8%83%A1%E5%AE%87%E8%BE%89%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200617163013686.png" alt="image-20200617163013686"></p>
<p>代码实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//3个停车位</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();<span class="comment">//获取</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"抢到车位"</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"离开车位"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();<span class="comment">//释放</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>原理：</strong></p>
<p>==semaphore.acquire()== 获取，假设如果已经满了，等待，等待被释放为止！</p>
<p>==semaphore.release()== 释放，会将当前的信号量释放+1，然后唤醒等待的线程！</p>
<p>作用：多个共享资源互斥的使用!并发限流，控制最大的线程数!</p>
<h2 id="9、读写锁"><a href="#9、读写锁" class="headerlink" title="9、读写锁"></a>9、读写锁</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 写锁（独占锁）一次只能被一个线程占有</span></span><br><span class="line"><span class="comment"> * 读锁（共享锁）可以被多个线程同时占有</span></span><br><span class="line"><span class="comment"> * ReadWriteLock</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line"><span class="comment">//        MyCache myCache = new MyCache();</span></span><br><span class="line">        MyCacheLock myCache = <span class="keyword">new</span> MyCacheLock();</span><br><span class="line">        <span class="comment">//写入</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> finalI = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                myCache.put(finalI+<span class="string">""</span>,finalI);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//读取</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> finalI = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                myCache.get(finalI+<span class="string">""</span>);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义缓存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//普通的，没有synchronized或者lock锁，一条线程可能刚写入时，还没被写入完毕就被另一条线程插队</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCache</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存，写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key,Object value)</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"写入"</span>+key);</span><br><span class="line">        map.put(key, value);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"写入完毕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取，读</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"读取"</span>+key);</span><br><span class="line">        Object o = map.get(key);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"读取完毕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ReentrantLock重入锁和ReentrantReadWriteLock读写锁</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCacheLock</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">//    Lock lock = new ReentrantLock();</span></span><br><span class="line">    <span class="comment">//读写锁</span></span><br><span class="line">    ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="comment">//存，写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key,Object value)</span></span>&#123;</span><br><span class="line"><span class="comment">//        lock.lock();</span></span><br><span class="line">        rwl.writeLock().lock();<span class="comment">//加锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"写入"</span>+key);</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"写入完毕"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//            lock.unlock();</span></span><br><span class="line">            rwl.writeLock().unlock();<span class="comment">//解锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取，读</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line"><span class="comment">//        lock.lock();</span></span><br><span class="line">        rwl.readLock().lock();<span class="comment">//加锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"读取"</span>+key);</span><br><span class="line">            Object o = map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"读取完毕"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//            lock.unlock();</span></span><br><span class="line">            rwl.readLock().lock();<span class="comment">//解锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>独占锁（写锁）一次只能被一个线程占有</p>
<p>共享锁（读锁）可以被多个线程同时占有</p>
</blockquote>
<h2 id="10、阻塞队列"><a href="#10、阻塞队列" class="headerlink" title="10、阻塞队列"></a>10、阻塞队列</h2><blockquote>
<p>队列</p>
</blockquote>
<p><img src="C:%5CUsers%5C%E8%83%A1%E5%AE%87%E8%BE%89%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200617210917375.png" alt="image-20200617210917375"></p>
<blockquote>
<p>阻塞队列</p>
</blockquote>
<p><img src="C:%5CUsers%5C%E8%83%A1%E5%AE%87%E8%BE%89%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200617211128377.png" alt="image-20200617211128377"></p>
<blockquote>
<p>BlockingQueue的位置</p>
</blockquote>
<p><img src="C:%5CUsers%5C%E8%83%A1%E5%AE%87%E8%BE%89%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200617214254139.png" alt="image-20200617214254139"></p>
<p>什么情况下会使用阻塞队列：多线程并发处理，线程池！</p>
<p><strong>四组API</strong></p>
<table>
<thead>
<tr>
<th>方式</th>
<th>抛出异常</th>
<th>有返回值</th>
<th>阻塞等待</th>
<th>超时等待</th>
</tr>
</thead>
<tbody><tr>
<td>添加</td>
<td>add()</td>
<td>offer()</td>
<td>put()</td>
<td>offer( , , )</td>
</tr>
<tr>
<td>移动</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll( , )</td>
</tr>
<tr>
<td>判断列首</td>
<td>element</td>
<td>peek</td>
<td>——</td>
<td>——</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hyh.blockingqueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="comment">//        test1();</span></span><br><span class="line"><span class="comment">//        test2();</span></span><br><span class="line"><span class="comment">//        test3();</span></span><br><span class="line">        test4();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 抛出异常stat</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//capacity:队列的容量</span></span><br><span class="line">        ArrayBlockingQueue blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(blockingQueue.add(<span class="string">"a"</span>));<span class="comment">//返回true</span></span><br><span class="line">        System.out.println(blockingQueue.add(<span class="string">"b"</span>));<span class="comment">//返回true</span></span><br><span class="line">        System.out.println(blockingQueue.add(<span class="string">"c"</span>));<span class="comment">//返回true</span></span><br><span class="line">        System.out.println(blockingQueue.element());<span class="comment">//返回a 查看队首元素是谁</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.add("d"));</span></span><br><span class="line">        <span class="comment">//抛出异常：java.lang.IllegalStateException: Queue full</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"==================="</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(blockingQueue.remove());</span><br><span class="line">        System.out.println(blockingQueue.remove());</span><br><span class="line">        System.out.println(blockingQueue.remove());</span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.remove());</span></span><br><span class="line">        <span class="comment">//抛出异常：java.util.NoSuchElementException</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不抛异常，有返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ArrayBlockingQueue blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">"a"</span>));<span class="comment">//true</span></span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">"b"</span>));<span class="comment">//true</span></span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">"c"</span>));<span class="comment">//true</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.offer("d")); //不抛异常，返回false</span></span><br><span class="line">        System.out.println(blockingQueue.peek());<span class="comment">//查看队首元素</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"==================="</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.poll());//不抛异常，返回null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不抛异常，就在哪阻塞,一直等待</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ArrayBlockingQueue blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">3</span>);</span><br><span class="line">        blockingQueue.put(<span class="string">"a"</span>);</span><br><span class="line">        blockingQueue.put(<span class="string">"b"</span>);</span><br><span class="line">        blockingQueue.put(<span class="string">"c"</span>);</span><br><span class="line"><span class="comment">//        blockingQueue.put("d");//队列满了后就一直阻塞</span></span><br><span class="line">        System.out.println(blockingQueue.take());</span><br><span class="line">        System.out.println(blockingQueue.take());</span><br><span class="line">        System.out.println(blockingQueue.take());</span><br><span class="line">        System.out.println(blockingQueue.take());<span class="comment">//队列为空，取不出元素就一直阻塞，等待</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 超时等待，不会一直等待，到了时间就走人（退出）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ArrayBlockingQueue&lt;Object&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">"a"</span>));</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">"b"</span>));</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">"c"</span>));</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">"d"</span>, <span class="number">2</span>, TimeUnit.SECONDS));<span class="comment">//等待超过2秒就退出</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"==================="</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        System.out.println(blockingQueue.poll(<span class="number">2</span>, TimeUnit.SECONDS));<span class="comment">//等待超过2秒就退出</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>SynchronousQueue 同步队列</p>
</blockquote>
<p>阻塞队列的容量是可以设置多少的，同步队列的容量最多为1</p>
<p>也就是说进去一个元素了，只能等待这个元素被取出来，才能进入下一个元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.hyh.synchronousqueue;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.SynchronousQueue;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 同步队列</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class SynchronousQueueDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        SynchronousQueue&lt;String&gt; synchronousQueue &#x3D; new SynchronousQueue&lt;&gt;();</span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot; put 1&quot; );</span><br><span class="line">                synchronousQueue.put(&quot;1&quot;);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot; put 2&quot; );</span><br><span class="line">                synchronousQueue.put(&quot;2&quot;);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot; put 3&quot; );</span><br><span class="line">                synchronousQueue.put(&quot;3&quot;);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;T1&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(2);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;take&quot; + synchronousQueue.take());</span><br><span class="line">                TimeUnit.SECONDS.sleep(2);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;take&quot; + synchronousQueue.take());</span><br><span class="line">                TimeUnit.SECONDS.sleep(2);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;take&quot; + synchronousQueue.take());</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;T2&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="11、线程池"><a href="#11、线程池" class="headerlink" title="11、线程池"></a>11、线程池</h2><p>线程池：三大方法、7大参数、4种拒绝策略</p>
<blockquote>
<p>池化技术</p>
</blockquote>
<p>程序的运行，本质：占用系统的资源！优化资源的使用 ！=&gt;池化技术</p>
<p>线程池的创建和销毁的开销很大，线程池的使用降低了资源的消耗</p>
<p><strong>线程池的好处：</strong></p>
<ol>
<li><p>降低资源的消耗</p>
</li>
<li><p>提高响应速度</p>
</li>
<li><p>方便管理</p>
<p>线程池：线程复用、可以控制最大并发数、管理线程</p>
</li>
</ol>
<p><img src="C:%5CUsers%5C%E8%83%A1%E5%AE%87%E8%BE%89%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200618183117906.png" alt="image-20200618183117906"></p>
<blockquote>
<p>三大方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hyh.Threadpool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Executors 工具类、3大方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建线程池</span></span><br><span class="line"><span class="comment">//        ExecutorService threadPool = Executors.newSingleThreadExecutor(); //单个线程的线程池</span></span><br><span class="line"><span class="comment">//        ExecutorService threadPool = Executors.newFixedThreadPool(7); //固定大小的线程池</span></span><br><span class="line">        ExecutorService threadPool = Executors.newCachedThreadPool(); <span class="comment">//缓存线程池，大小可以伸缩的</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">                <span class="comment">//创建线程池后，用线程池创建线程</span></span><br><span class="line">                threadPool.execute(()-&gt;&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" ok"</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//一定要关闭线程池</span></span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>7大参数</p>
</blockquote>
<p>源码分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,<span class="comment">//最大核心线程数：21亿 易出现OOM</span></span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//核心：3个方法底层都是new了一个ThreadPoolExecutor类</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,//核心线程池数</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,//最大核心线程池数</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,//超时不候</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,//超时单位</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,//阻塞队列</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,//线程工厂，创建线程的</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span> </span>&#123;<span class="comment">//拒绝策略</span></span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">                <span class="keyword">null</span> :</span><br><span class="line">                AccessController.getContext();</span><br><span class="line">        <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">        <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="C:%5CUsers%5C%E8%83%A1%E5%AE%87%E8%BE%89%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200619144018775.png" alt="image-20200619144018775"></p>
<blockquote>
<p>四种拒绝策略</p>
</blockquote>
<p><img src="C:%5CUsers%5C%E8%83%A1%E5%AE%87%E8%BE%89%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200619145204313.png" alt="image-20200619145204313"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 四种拒绝策略</span></span><br><span class="line"><span class="comment"> *   new ThreadPoolExecutor.AbortPolicy()//银行满了（超过最大承载），还有人进去，不处理这个人的，抛出异常</span></span><br><span class="line"><span class="comment"> *   new ThreadPoolExecutor.CallerRunsPolicy()//银行满了，还有人进去，不会抛出异常，但是会将这个人打发回原线程</span></span><br><span class="line"><span class="comment"> *   new ThreadPoolExecutor.DiscardPolicy()//银行满了，还有人进去，不会抛出异常，但是会将这个人直接丢掉</span></span><br><span class="line"><span class="comment"> *   new ThreadPoolExecutor.DiscardOldestPolicy()//银行满了，还有人进去，不会抛出异常，但是这个人会尝试与最早的任务竞争</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>自定义线程池</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//自定义线程池</span></span><br><span class="line">        ThreadPoolExecutor threadPool = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">2</span>,</span><br><span class="line">                <span class="number">5</span>,</span><br><span class="line">                <span class="number">3</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingQueue(<span class="number">3</span>),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//最大承载:阻塞队列 + 最大核心线程池数</span></span><br><span class="line">            <span class="comment">//超出则抛出异常：RejectedExecutionException</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">                <span class="comment">//创建线程池后，用线程池创建线程</span></span><br><span class="line">                threadPool.execute(()-&gt;&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" ok"</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//一定要关闭线程池</span></span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>了解CPU密集型和IO密集型</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;最大线程到底如何定义</span><br><span class="line">        &#x2F;&#x2F;1、CPU 密集型，电脑CPU是几核巨设置几，可以保持CPU的效率最高</span><br><span class="line">        &#x2F;&#x2F;2、IO 密集型，判断你程序中十分耗IO的线程</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;获取CPU的核数</span><br><span class="line">&#x2F;&#x2F;        System.out.println(Runtime.getRuntime().availableProcessors());</span><br></pre></td></tr></table></figure>



<h2 id="12、四大函数式接口"><a href="#12、四大函数式接口" class="headerlink" title="12、四大函数式接口"></a>12、四大函数式接口</h2><p>lambda表达式、链式编程、函数式接口、Stream流式计算</p>
<blockquote>
<p>函数式接口：只有一个方法的接口</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span><span class="comment">//函数式接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span></span><br><span class="line"><span class="comment">     * to create a thread, starting the thread causes the object's</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span></span><br><span class="line"><span class="comment">     * thread.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span></span><br><span class="line"><span class="comment">     * take any action whatsoever.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     java.lang.Thread#run()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="C:%5CUsers%5C%E8%83%A1%E5%AE%87%E8%BE%89%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200619164932260.png" alt="image-20200619164932260"></p>
<p>代码测试：</p>
<p><img src="C:%5CUsers%5C%E8%83%A1%E5%AE%87%E8%BE%89%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200619170122440.png" alt="image-20200619170122440"></p>
<blockquote>
<p>函数型接口 Function</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hyh.function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Function 函数型接口</span></span><br><span class="line"><span class="comment"> * Lambda表达式的本质：作为函数式接口的实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        Function&lt;String, String&gt; function = new Function&lt;String, String&gt;() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public String apply(String str) &#123;</span></span><br><span class="line"><span class="comment">//                return str;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;;</span></span><br><span class="line">        Function&lt;String,String&gt; function = (str)-&gt;&#123;<span class="keyword">return</span> str;&#125;;<span class="comment">//lambda表达式实现</span></span><br><span class="line">        String s =  function.apply(<span class="string">"hello"</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>断定型接口 Predicate</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hyh.function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 断定型接口：有一个输入参数，返回值只能是布尔型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        Predicate&lt;String&gt; predicate = new Predicate&lt;String&gt;() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public boolean test(String str) &#123;</span></span><br><span class="line"><span class="comment">//                return str.isEmpty();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;;</span></span><br><span class="line">        Predicate&lt;String&gt; predicate = (str)-&gt; &#123; <span class="keyword">return</span> str.isEmpty(); &#125;;</span><br><span class="line">        System.out.println(predicate.test(<span class="string">"abc"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Consumer 消费型接口</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hyh.function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Consumer 消费型接口：只有输入参数，没有返回值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        Consumer&lt;String&gt; consumer = new Consumer&lt;String&gt;() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public void accept(String str) &#123;</span></span><br><span class="line"><span class="comment">//                System.out.println(s);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;;</span></span><br><span class="line">        Consumer&lt;String&gt; consumer = (str)-&gt;&#123; System.out.println(str); &#125;;</span><br><span class="line">        consumer.accept(<span class="string">"java"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Supplier 供给型接口</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hyh.function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Supplier 供给型接口:没有参数，只有返回值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        Supplier&lt;Integer&gt; supplier = new Supplier&lt;Integer&gt;() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public Integer get() &#123;</span></span><br><span class="line"><span class="comment">//                return 1024;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;;</span></span><br><span class="line">        Supplier&lt;Integer&gt; supplier = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(supplier.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="13、Stream流式计算"><a href="#13、Stream流式计算" class="headerlink" title="13、Stream流式计算"></a>13、Stream流式计算</h2><blockquote>
<p>什么是stream流式计算</p>
</blockquote>
<p>大数据：存储 + 计算</p>
<p>集合、MySQL本质就是存储东西的；</p>
<p>计算都应该交给流来操作</p>
<p><img src="C:%5CUsers%5C%E8%83%A1%E5%AE%87%E8%BE%89%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200619202854189.png" alt="image-20200619202854189"></p>
<p>代码实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hyh.stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目要求：一分钟内完成此题，只能用一行代码实现！</span></span><br><span class="line"><span class="comment"> * 现在有5个用户！筛选：</span></span><br><span class="line"><span class="comment"> * 1、ID 必须是偶数</span></span><br><span class="line"><span class="comment"> * 2、年龄必须大于23岁</span></span><br><span class="line"><span class="comment"> * 3、用户名转为大写字母</span></span><br><span class="line"><span class="comment"> * 4、用户字母倒着排序</span></span><br><span class="line"><span class="comment"> * 5、只输入一个用户</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User u1 = <span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">"a"</span>,<span class="number">21</span>);</span><br><span class="line">        User u2 = <span class="keyword">new</span> User(<span class="number">2</span>,<span class="string">"b"</span>,<span class="number">22</span>);</span><br><span class="line">        User u3 = <span class="keyword">new</span> User(<span class="number">3</span>,<span class="string">"c"</span>,<span class="number">23</span>);</span><br><span class="line">        User u4 = <span class="keyword">new</span> User(<span class="number">4</span>,<span class="string">"d"</span>,<span class="number">24</span>);</span><br><span class="line">        User u5 = <span class="keyword">new</span> User(<span class="number">5</span>,<span class="string">"e"</span>,<span class="number">25</span>);</span><br><span class="line">        User u6 = <span class="keyword">new</span> User(<span class="number">6</span>,<span class="string">"f"</span>,<span class="number">26</span>);</span><br><span class="line">        <span class="comment">//集合就是存储</span></span><br><span class="line">        List&lt;User&gt; list = Arrays.asList(u1, u2, u3, u4, u5,u6);</span><br><span class="line"><span class="comment">//        for (User user : list) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(user);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">//计算交给Stream流</span></span><br><span class="line"></span><br><span class="line">        list.stream()</span><br><span class="line">                .filter(u-&gt;&#123;<span class="keyword">return</span> u.getId()%<span class="number">2</span>==<span class="number">0</span>;&#125;)</span><br><span class="line">                .filter(u-&gt;&#123;<span class="keyword">return</span> u.getAge()&gt;<span class="number">23</span>;&#125;)</span><br><span class="line">                .map(u-&gt;&#123;<span class="keyword">return</span> u.getName().toUpperCase();&#125;)</span><br><span class="line">                .sorted((user1,user2)-&gt;&#123;<span class="keyword">return</span> user2.compareTo(user1);&#125;)</span><br><span class="line">                .limit(<span class="number">1</span>)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="14、ForkJoin"><a href="#14、ForkJoin" class="headerlink" title="14、ForkJoin"></a>14、ForkJoin</h2><h2 id="15、异步回调"><a href="#15、异步回调" class="headerlink" title="15、异步回调"></a>15、异步回调</h2><blockquote>
<p>异步调用</p>
</blockquote>
<p>同步调用：提交完成任务后，在原地等待任务执行完毕后，拿到返回结果，再去执行下一步。</p>
<p>异步调用：提交完成任务后，不会等待任务执行完毕，拿到结果，而是接着执行下一步。</p>
<blockquote>
<p>Future：对将来的结果进行建模</p>
</blockquote>
<p>代码实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hyh.future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步调用：CompletableFuture</span></span><br><span class="line"><span class="comment"> *      异步执行</span></span><br><span class="line"><span class="comment"> *      成功回调</span></span><br><span class="line"><span class="comment"> *      失败回调</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//发起一个请求,没有返回值的 runAsync 异步回调</span></span><br><span class="line"><span class="comment">//        CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.runAsync(()-&gt;&#123;</span></span><br><span class="line"><span class="comment">//            try &#123;</span></span><br><span class="line"><span class="comment">//                TimeUnit.SECONDS.sleep(2);</span></span><br><span class="line"><span class="comment">//            &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//                e.printStackTrace();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            System.out.println(Thread.currentThread().getName() + "runAsync=&gt;void");</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line"><span class="comment">//        System.out.println("aaaaa");</span></span><br><span class="line"><span class="comment">//        completableFuture.get();//获取执行结果</span></span><br><span class="line">        <span class="comment">//有返回值的 supplyAsync 异步回调</span></span><br><span class="line">        <span class="comment">//ajax, 成功和失败的回调</span></span><br><span class="line">        CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(completableFuture.whenComplete((t, u) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"t=&gt;"</span> + t);</span><br><span class="line">            System.out.println(<span class="string">"u=&gt;"</span> + u);</span><br><span class="line">        &#125;).exceptionally((e) -&gt; &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"fail"</span>;</span><br><span class="line">        &#125;).get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="16、JMM"><a href="#16、JMM" class="headerlink" title="16、JMM"></a>16、JMM</h2><blockquote>
<p>Volatile关键字</p>
</blockquote>
<p>Volatile 是==Java虚拟机提供的轻量级的同步机制==</p>
<ol>
<li>保证可见性</li>
<li>不保证原子性</li>
<li>禁止指令重排</li>
</ol>
<blockquote>
<p>什么是JMM</p>
</blockquote>
<p>Java Memory Model：顾名思义，Java内存模型</p>
<p><strong>关于JMM的一些同步的约定</strong></p>
<ol>
<li>线程加锁前，必须读取主存中的最新工作内存中</li>
<li>线程解锁前，必须把共享变量立刻刷回主存</li>
<li>加锁和解锁是同一把锁</li>
</ol>
<blockquote>
<p>JMM内存的划分</p>
</blockquote>
<p><img src="C:%5CUsers%5C%E8%83%A1%E5%AE%87%E8%BE%89%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200620190557694.png" alt="image-20200620190557694"></p>
<blockquote>
<p>内存交互操作</p>
</blockquote>
<p><strong>内存交互操作有8种</strong>，虚拟机实现必须保证每一个操作都是原子的，不可在分的（对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许例外）</p>
<ul>
<li><p>lock   （锁定）：作用于主内存的变量，把一个变量标识为线程独占状态</p>
</li>
<li><p>unlock （解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</p>
</li>
<li><p>read  （读取）：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用</p>
</li>
<li><p>load   （载入）：作用于工作内存的变量，它把read操作从主存中变量放入工作内存中</p>
</li>
<li><p>use   （使用）：作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令</p>
</li>
<li><p>assign （赋值）：作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中</p>
</li>
<li><p>store  （存储）：作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用</p>
</li>
<li><p>write 　（写入）：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中</p>
</li>
</ul>
<p><strong>JMM对这八种指令的使用，制定了如下规则</strong>：</p>
<ul>
<li><p>不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write</p>
</li>
<li><p>不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存</p>
</li>
<li><p>不允许一个线程将没有assign的数据从工作内存同步回主内存</p>
</li>
<li><p>一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是怼变量实施use、store操作之前，必须经过assign和load操作</p>
</li>
<li><p>一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁</p>
</li>
<li><p>如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值</p>
</li>
<li><p>如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量</p>
</li>
<li><p>对一个变量进行unlock操作之前，必须把此变量同步回主内存</p>
</li>
</ul>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hyh.tvolatile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JMMDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; <span class="comment">//main</span></span><br><span class="line">       <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">           <span class="keyword">while</span>(num == <span class="number">0</span>)&#123;	<span class="comment">//线程A</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,<span class="string">"A"</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        num = <span class="number">1</span>;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果：A线程睡眠1秒，mian线程就已经把主内存里的num修改为1，但是A线程并不知道，所有一直在while程序中循环</span></span><br></pre></td></tr></table></figure>

<p><img src="C:%5CUsers%5C%E8%83%A1%E5%AE%87%E8%BE%89%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200620201427832.png" alt="image-20200620201427832"></p>
<p>内存分析：</p>
<p><img src="C:%5CUsers%5C%E8%83%A1%E5%AE%87%E8%BE%89%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200620200812486.png" alt="image-20200620200812486"></p>
<h2 id="17、Volatile"><a href="#17、Volatile" class="headerlink" title="17、Volatile"></a>17、Volatile</h2><blockquote>
<p>保证可见性</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hyh.tvolatile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JMMDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//不加volatile 程序死循环</span></span><br><span class="line">    <span class="comment">//加volatile 线程A就知道主内存被修改了，保证可见性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; <span class="comment">//main</span></span><br><span class="line">       <span class="keyword">new</span> Thread(()-&gt;&#123;  <span class="comment">//线程A</span></span><br><span class="line">           <span class="keyword">while</span>(num == <span class="number">0</span>)&#123;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,<span class="string">"A"</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        num = <span class="number">1</span>;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不保证原子性</p>
</blockquote>
<p>原子性：不可分割</p>
<p>线程A在执行任务的时候，不能被打扰的，也不能被分割。</p>
<p>代码实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hyh.tvolatile;</span><br><span class="line"><span class="comment">//synchronized 保证原子性</span></span><br><span class="line"><span class="comment">//Volatile 不保证原子性</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JMMDemo2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//理论上结果为20000</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                    add();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">2</span>)&#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() +<span class="string">" "</span>+ num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果不用lock和synchronized怎么保证原子性</strong></p>
<p>上述实例的num不是一个原子性的操作</p>
<p><img src="C:%5CUsers%5C%E8%83%A1%E5%AE%87%E8%BE%89%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200620210211639.png" alt="image-20200620210211639"></p>
<p>使用原子类</p>
<p><img src="C:%5CUsers%5C%E8%83%A1%E5%AE%87%E8%BE%89%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200620210535827.png" alt="image-20200620210535827"></p>
<p>代码实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hyh.tvolatile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">//synchronized 保证原子性</span></span><br><span class="line"><span class="comment">//Volatile 不保证原子性</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JMMDemo2</span> </span>&#123;</span><br><span class="line"><span class="comment">//    private volatile static int num = 0;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> AtomicInteger num = <span class="keyword">new</span> AtomicInteger();<span class="comment">//使用原子类  底层CAS</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//        num++;//不是一个原子性的操作</span></span><br><span class="line">        num.getAndIncrement(); <span class="comment">//getAndIncrement也是+1的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//理论上结果为20000</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                    add();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">2</span>)&#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() +<span class="string">" "</span>+ num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>避免指令重排</p>
</blockquote>
<p>指令重排：计算机并不是按照你写的程序的顺序去执行</p>
<p>源代码–&gt;编译器优化的重排–&gt;指令并行也可能会重排–&gt;内存系统也会重排–&gt;执行</p>
<p>==处理器在进行指令重排的时候，会考虑：数据之间的依赖性!==</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int x &#x3D; 1;</span><br><span class="line">int y &#x3D; 2;</span><br><span class="line">x &#x3D; x + 5;</span><br><span class="line">y &#x3D; x * x;</span><br><span class="line"></span><br><span class="line">期望的执行顺序：1234，但可能执行的时候变成：2314 ，1324</span><br><span class="line">但不可能是 4123，因为4是依赖于1的</span><br></pre></td></tr></table></figure>

<p>进一步理解：假设a b x y 这四个值默认是 0;</p>
<table>
<thead>
<tr>
<th>线程A</th>
<th>线程B</th>
</tr>
</thead>
<tbody><tr>
<td>x=a</td>
<td>y=b</td>
</tr>
<tr>
<td>b=1</td>
<td>a=2</td>
</tr>
</tbody></table>
<p>正常的结果：x=0，y=0</p>
<p>可能由于指令重排后执行顺序变化</p>
<table>
<thead>
<tr>
<th>线程A</th>
<th>线程B</th>
</tr>
</thead>
<tbody><tr>
<td>b=1</td>
<td>a=2</td>
</tr>
<tr>
<td>x=a</td>
<td>y=b</td>
</tr>
</tbody></table>
<p>意外的结果：x = 2，y=1</p>
<blockquote>
<p>volatile如何避免指令重排的</p>
</blockquote>
<p><strong>volatile可以避免指令重排</strong></p>
<p>内存屏障，CPU指令。作用：</p>
<ol>
<li>保证特定的操作的执行顺序</li>
<li>可以保证某些变量的内存可见性（利用这些特性volatile实现了可见性）</li>
</ol>
<p><img src="C:%5CUsers%5C%E8%83%A1%E5%AE%87%E8%BE%89%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200620221629462.png" alt="image-20200620221629462"></p>
<p>Volatile是可以保持可见性。不能保持原子性，由于内存屏障，可以保证指令重排的现象产生</p>
<h2 id="18、单例模式"><a href="#18、单例模式" class="headerlink" title="18、单例模式"></a>18、单例模式</h2><h2 id="19、深入理解CAS"><a href="#19、深入理解CAS" class="headerlink" title="19、深入理解CAS"></a>19、深入理解CAS</h2><blockquote>
<p>什么是CAS</p>
</blockquote>
<p>CAS，全称Compare-and-Swap，是指比较和交换，一种特殊的处理器指令。</p>
<blockquote>
<p>Unsafe类</p>
</blockquote>
<p><img src="C:%5CUsers%5C%E8%83%A1%E5%AE%87%E8%BE%89%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200621152128706.png" alt="image-20200621152128706"></p>
<p><img src="C:%5CUsers%5C%E8%83%A1%E5%AE%87%E8%BE%89%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200621154059968.png" alt="image-20200621154059968"></p>
<p>CAS：比较当前工作内存中的值和主内存中的值，如果这个值是期望的值，那么则执行操作；如果不是就一直循环（因为底层是自旋锁）</p>
<p><strong>缺点：</strong></p>
<ol>
<li>循环会耗时</li>
<li>一次性只能保证一个共享变量的原子性</li>
<li>ABA问题</li>
</ol>
<blockquote>
<p>CAS：ABA问题</p>
</blockquote>
<h2 id="20、原子引用"><a href="#20、原子引用" class="headerlink" title="20、原子引用"></a>20、原子引用</h2><blockquote>
<p>解决ABA问题，引入原子引用！对应的思想：乐观锁！</p>
</blockquote>
<h2 id="21、各种锁的理解"><a href="#21、各种锁的理解" class="headerlink" title="21、各种锁的理解"></a>21、各种锁的理解</h2><h3 id="1、公平锁、非公平锁"><a href="#1、公平锁、非公平锁" class="headerlink" title="1、公平锁、非公平锁"></a>1、公平锁、非公平锁</h3><p>公平锁：先来后到。无论线程需要多长时间完成，都必须先来的线程执行完了，后面的线程才能执行</p>
<p>非公平锁（默认）：可以插队。时间短的线程如果排在时间长的线程后面，可以插队到前面完成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync = <span class="keyword">new</span> NonfairSync();<span class="comment">//NonfairSync:非公平锁</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();<span class="comment">//FairSync:公平锁</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、可重入锁"><a href="#2、可重入锁" class="headerlink" title="2、可重入锁"></a>2、可重入锁</h3><p>所有的锁都是可重入锁（递归锁）</p>
<p><img src="C:%5CUsers%5C%E8%83%A1%E5%AE%87%E8%BE%89%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200621170206951.png" alt="image-20200621170206951"></p>
<blockquote>
<p>synchronized版</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hyh.reentrantlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可重入锁:synchronized,lock</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">           Phone.sms();</span><br><span class="line">        &#125;,<span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        TimeUnit.SECONDS.sleep(1);</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">           Phone.sms();</span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sms</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"=&gt;sms"</span>);</span><br><span class="line">        call();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"=&gt;call"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>lock版</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hyh.reentrantlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        OnePhone phone = <span class="keyword">new</span> OnePhone();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone.sms();</span><br><span class="line">        &#125;,<span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone.sms();</span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OnePhone</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sms</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"=&gt;sms"</span>);</span><br><span class="line">            call();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"=&gt;call"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3、自旋锁"><a href="#3、自旋锁" class="headerlink" title="3、自旋锁"></a>3、自旋锁</h3><p>spinlock</p>
<p><img src="C:%5CUsers%5C%E8%83%A1%E5%AE%87%E8%BE%89%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200621154059968.png" alt="image-20200621154059968"></p>
<p>自定义一个自旋锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hyh.spinlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自旋锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Thread是引用对象，默认为null</span></span><br><span class="line">    AtomicReference&lt;Thread&gt; atomicReference = <span class="keyword">new</span> AtomicReference();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"==&gt;myLock"</span>);</span><br><span class="line">        <span class="comment">//自旋锁</span></span><br><span class="line">        <span class="keyword">while</span>(atomicReference.compareAndSet(<span class="keyword">null</span>,thread))&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myUnLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"==&gt;myUnLock"</span>);</span><br><span class="line">        atomicReference.compareAndSet(thread,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试自旋锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hyh.spinlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSpinLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        SpinLockDemo spinLock = <span class="keyword">new</span> SpinLockDemo();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            spinLock.myLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                spinLock.myUnLock();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;,<span class="string">"T1"</span>).start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            spinLock.myLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                spinLock.myUnLock();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;,<span class="string">"T2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果</p>
<p><img src="C:%5CUsers%5C%E8%83%A1%E5%AE%87%E8%BE%89%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200621184005846.png" alt="image-20200621184005846"></p>
<h3 id="4、死锁"><a href="#4、死锁" class="headerlink" title="4、死锁"></a>4、死锁</h3><blockquote>
<p>死锁是什么</p>
</blockquote>
<p>不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁</p>
<p><img src="C:%5CUsers%5C%E8%83%A1%E5%AE%87%E8%BE%89%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200621184727560.png" alt="image-20200621184727560"></p>
<p>死锁的测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hyh.deadlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">//死锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String lockA = <span class="string">"lockA"</span>;</span><br><span class="line">        String lockB = <span class="string">"lockB"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread(lockA,lockB)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread(lockB,lockA)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String lockA;</span><br><span class="line">    <span class="keyword">private</span> String lockB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String lockA,String lockB)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lockA = lockA;</span><br><span class="line">        <span class="keyword">this</span>.lockB = lockB;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lockA)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"lock: "</span> + lockA + <span class="string">"=&gt; get"</span> +lockB);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (lockB)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"lock: "</span> + lockB + <span class="string">"=&gt; get"</span> +lockA);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>怎么排查死锁和解决</p>
</blockquote>
<p>1、使用 ==jps - l== 命令定位进程号</p>
<p><img src="C:%5CUsers%5C%E8%83%A1%E5%AE%87%E8%BE%89%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200621194903231.png" alt="image-20200621194903231"></p>
<p>2、使用 ==jstack+进程号== 找到死锁问题</p>
<p> <img src="C:%5CUsers%5C%E8%83%A1%E5%AE%87%E8%BE%89%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200621195006973.png" alt="image-20200621195006973"></p>
]]></content>
      <categories>
        <category>JUC</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
</search>
